// this is rough sketch of some file that should be generated by codegen

// use

// actual generated part

// prelude
pub type Box<T> = std::boxed::Box<T>;

// generated for Nat from
// -- dependobuf syntax
// enum Nat {
//     Zero {}
//     Suc {
//         pred Nat
//     }
// }
// -- elaborated ast
// Its Type
// Type {
//     dependencies: Vec::new(),
//     constructor_names: ConstructorNames::OfEnum(
//         ["Zero", "Suc"].into_iter().map(|s| s.to_owned()).collect(),
//     ),
// };
// Corresponding part of constructors
// [
//     (
//         "Zero",
//         Constructor {
//             implicits: Vec::new(),
//             fields: Vec::new(),
//             result_type: Expression::Type {
//                 name: "Nat".to_owned(),
//                 dependencies: Rec::new([]),
//             },
//         },
//     ),
//     (
//         "Suc",
//         Constructor {
//             implicits: Vec::new(),
//             fields: vec![(
//                 "pred".to_owned(),
//                 Expression::Type {
//                     name: "Nat".to_owned(),
//                     dependencies: Rec::new([]),
//                 },
//             )],
//             result_type: Expression::Type {
//                 name: "Nat".to_owned(),
//                 dependencies: Rec::new([]),
//             },
//         },
//     ),
// ];

// module that contains all implementation
pub mod nat {
    // general prelude
    use super::{Box, ConstructorError, Message};

    // optional part where used types are imported

    // body definition
    #[derive(PartialEq, Eq)]
    pub enum Body {
        Zero,
        Suc { pred: Box<Self> },
    }

    // dependencies definition
    #[derive(PartialEq, Eq)]
    pub struct Dependencies {}

    // alias for the generated type
    pub type Nat = Message<Body, Dependencies>;

    // inherit implementation with all constructors
    impl Nat {
        pub fn zero() -> Result<Self, ConstructorError> {
            let body = Body::Zero;
            let dependencies = Dependencies {};
            Ok(Message { body, dependencies })
        }

        pub fn suc(pred: Nat) -> Result<Self, ConstructorError> {
            let body = Body::Suc {
                pred: Box::new(pred.body),
            };
            let dependencies = Dependencies {};
            Ok(Message { body, dependencies })
        }
    }
}

pub use nat::Nat;

// generated for Nat from
// -- dependobuf syntax
// enum Vec {
//     Zero {}
//     Suc {
//         pred Nat
//     }
// }
// -- elaborated ast
// Its Type
// Type {
//     dependencies: vec![("n".to_owned(), Expression::Type { name: "Nat".to_owned(), dependencies: Vec::new() })]
//     constructors: ConstructorNames::OfEnum(
//         ["Nil", "Cons"].into_iter().map(|s| s.to_owned()).collect(),
//     ),
// };
// Corresponding part of constructors
// [
//     (
//         "Nil".to_owned(),
//         Constructor {
//             implicits: Vec::new(),
//             fields: Vec::new(),
//             result_type: Expression::Type {
//                 name: "Vec".to_owned(),
//                 dependencies: Rec::new([Expression::Constructor {
//                     name: "Zero".to_owned(),
//                     implicits: Rec::new([]),
//                     arguments: Rec::new([])
//                 }]),
//             },
//         },
//     ),
//     (
//         "Cons".to_owned(),
//         Constructor {
//             implicits: vec![(
//                 "p".to_owned(),
//                 Expression::Type {
//                     name: "Nat".to_owned(),
//                     dependencies: Rec::new([]),
//                 },
//             )],
//             fields: vec![
//                 (
//                     "val".to_owned(),
//                     Expression::Type {
//                         name: "String".to_owned(),
//                         dependencies: Rec::new([]),
//                     },
//                 ),
//                 (
//                     "tail".to_owned(),
//                     Expression::Type {
//                         name: "Vec".to_owned(),
//                         dependencies: Rec::new([
//                             Expression::Variable { name: "p".to_owned() },
//                         ])
//                     }
//                 ),
//             ],
//             result_type: Expression::Type {
//                 name: "Vec".to_owned(),
//                 dependencies: Rec::new([Expression::Constructor {
//                     name: "Suc".to_owned(),
//                     implicits: Rec::new([]),
//                     arguments: Rec::new([
//                         Expression::Variable { name: "p".to_owned() }
//                     ]),
//                 }])
//             },
//         },
//     ),
// ];

pub mod vec {
    mod deps {
        pub use super::super::{Box, ConstructorError, Message};
        pub use super::super::{Nat, nat};
    }

    #[derive(PartialEq, Eq)]
    pub enum Body {
        Nil,
        Cons { val: u64, tail: deps::Box<Self> },
    }

    #[derive(PartialEq, Eq)]
    pub struct Dependencies {
        n: deps::Nat,
    }

    pub type Vec = deps::Message<Body, Dependencies>;

    impl Vec {
        pub fn nil() -> Result<Self, deps::ConstructorError> {
            let body = if () == () {
                Ok(Body::Nil)
            } else {
                Err(deps::ConstructorError::MismatchedDependencies)
            }?;
            let dependencies = Dependencies {
                n: deps::Nat::zero()?,
            };
            Ok(deps::Message { body, dependencies })
        }

        pub fn cons(p: deps::Nat, val: u64, tail: Self) -> Result<Self, deps::ConstructorError> {
            let body = if (tail.dependencies.n) == (p) {
                Ok(Body::Cons {
                    val,
                    tail: Box::new(tail.body),
                })
            } else {
                Err(deps::ConstructorError::MismatchedDependencies)
            }?;
            let dependencies = Dependencies { n: p };
            Ok(deps::Message { body, dependencies })
        }
    }
}

use vec::Vec;

mod Nat {
    mod deps {
        pub use super::{Box, ConstructorError, Message};
    }

    #[derive(PartialEq, Eq)]
    pub enum Body {
        Suc { pred: deps::Box<Nat> },
        Zero {},
    }

    #[derive(PartialEq, Eq)]
    struct Dependencies {}

    pub type Nat = deps::Message<Body, Dependencies>;

    pub fn Suc(pred: deps::Box<Nat>) -> Result<Self, deps::ConstructorError> {
        let body = if (()) == (()) {
            Ok(Body::Suc { pred: pred })
        } else {
            Err(deps::ConstructorError::MismatchedDependencies)
        }?;
        let dependencies = deps::Nat::Dependencies {};
        Ok(deps::Message {
            body: body,
            dependencies: dependencies,
        })
    }
    pub fn Zero() -> Result<Self, deps::ConstructorError> {
        let body = if () == () {
            Ok(Body::Zero {})
        } else {
            Err(deps::ConstructorError::MismatchedDependencies)
        }?;
        let dependencies = deps::Nat::Dependencies {};
        Ok(deps::Message {
            body: body,
            dependencies: dependencies,
        })
    }
}

use Nat::Nat;
