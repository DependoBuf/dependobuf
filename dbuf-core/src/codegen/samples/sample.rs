// this is rough sketch of some file that should be generated by codegen

mod utility {
    #[macro_export]
    macro_rules! try_block {
        ($($tt:tt)*) => {
            (|| -> std::result::Result<_, _> { $($tt)* })()
        };
    }
}

pub enum ConstructorError {
    MismatchedDependencies,
}

#[derive(PartialEq, Eq)]
pub struct Message<Body, Dependencies> {
    pub body: Body,
    pub dependencies: Dependencies,
}

// actual generated part

// prelude
pub type Box<T> = std::boxed::Box<T>;

// generated for Nat from
// -- dependobuf syntax
// enum Nat {
//     Zero {}
//     Suc {
//         pred Nat
//     }
// }
// -- elaborated ast
// Its Type
// Type {
//     dependencies: Vec::new(),
//     constructor_names: ConstructorNames::OfEnum(
//         ["Zero", "Suc"].into_iter().map(|s| s.to_owned()).collect(),
//     ),
// };
// Corresponding part of constructors
// [
//     (
//         "Zero",
//         Constructor {
//             implicits: Vec::new(),
//             fields: Vec::new(),
//             result_type: Expression::Type {
//                 name: "Nat".to_owned(),
//                 dependencies: Rec::new([]),
//             },
//         },
//     ),
//     (
//         "Suc",
//         Constructor {
//             implicits: Vec::new(),
//             fields: vec![(
//                 "pred".to_owned(),
//                 Expression::Type {
//                     name: "Nat".to_owned(),
//                     dependencies: Rec::new([]),
//                 },
//             )],
//             result_type: Expression::Type {
//                 name: "Nat".to_owned(),
//                 dependencies: Rec::new([]),
//             },
//         },
//     ),
// ];

// module that contains all implementation
pub mod nat {
    // general prelude
    use super::{Box, ConstructorError, Message};

    // optional part where used types are imported

    // body definition
    #[derive(PartialEq, Eq)]
    pub enum Body {
        Zero,
        Suc { pred: Box<Self> },
    }

    // dependencies definition
    #[derive(PartialEq, Eq)]
    pub struct Dependencies {}

    // alias for the generated type
    pub type Nat = Message<Body, Dependencies>;

    // inherit implementation with all constructors
    impl Nat {
        pub fn zero(dependencies: Dependencies) -> Result<Self, ConstructorError> {
            let body = Body::Zero;
            Ok(Message { body, dependencies })
        }

        pub fn suc(dependencies: Dependencies, pred: Nat) -> Result<Self, ConstructorError> {
            let body = Body::Suc {
                pred: Box::new(pred.body),
            };
            Ok(Message { body, dependencies })
        }
    }
}

pub use nat::Nat;

// generated for Nat from
// -- dependobuf syntax
// enum Vec {
//     Zero {}
//     Suc {
//         pred Nat
//     }
// }
// -- elaborated ast
// Its Type
// Type {
//     dependencies: vec![("n".to_owned(), Expression::Type { name: "Nat".to_owned(), dependencies: Vec::new() })]
//     constructors: ConstructorNames::OfEnum(
//         ["Nil", "Cons"].into_iter().map(|s| s.to_owned()).collect(),
//     ),
// };
// Corresponding part of constructors
// [
//     (
//         "Nil".to_owned(),
//         Constructor {
//             implicits: Vec::new(),
//             fields: Vec::new(),
//             result_type: Expression::Type {
//                 name: "Vec".to_owned(),
//                 dependencies: Rec::new([Expression::Type {
//                     name: "Nat".to_owned(),
//                     dependencies: Rec::new([])
//                 }]),
//             },
//         },
//     ),
//     (
//         "Cons".to_owned(),
//         Constructor {
//             implicits: vec![(
//                 "p".to_owned(),
//                 Expression::Type {
//                     name: "Nat".to_owned(),
//                     dependencies: Rec::new([]),
//                 },
//             )],
//             fields: vec![
//                 (
//                     "val".to_owned(),
//                     Expression::Type {
//                         name: "String".to_owned(),
//                         dependencies: Rec::new([]),
//                     },
//                 ),
//                 (
//                     "tail".to_owned(),
//                     Expression::Type {
//                         name: "Vec".to_owned(),
//                         dependencies: Rec::new([
//                             Expression::Variable { name: "p".to_owned() },
//                         ])
//                     }
//                 ),
//             ],
//             result_type: Expression::Type {
//                 name: "Vec".to_owned(),
//                 dependencies: Rec::new([Expression::Constructor {
//                     name: "Suc".to_owned(),
//                     implicits: Rec::new([]),
//                     arguments: Rec::new([
//                         Expression::Variable { name: "p".to_owned() }
//                     ]),
//                 }])
//             },
//         },
//     ),
// ];

pub mod vec {
    mod deps {
        pub use super::super::{nat, Nat};
        pub use super::super::{Box, ConstructorError, Message};
    }

    #[derive(PartialEq, Eq)]
    pub enum Body {
        Nil,
        Cons { val: u64, tail: deps::Box<Self> },
    }

    #[derive(PartialEq, Eq)]
    pub struct Dependencies {
        n: deps::Nat,
    }

    pub type Vec = deps::Message<Body, Dependencies>;

    impl Vec {
        pub fn nil(dependencies: Dependencies) -> Result<Self, deps::ConstructorError> {
            let body = if let (deps::nat::Body::Zero) = (&dependencies.n.body) {
                if () == () {
                    Ok(Body::Nil)
                } else {
                    Err(deps::ConstructorError::MismatchedDependencies)
                }
            } else {
                Err(deps::ConstructorError::MismatchedDependencies)
            }?;
            Ok(deps::Message { body, dependencies })
        }

        pub fn cons(
            dependencies: Dependencies,
            val: u64,
            tail: Self,
        ) -> Result<Self, deps::ConstructorError> {
            let body = if let (deps::nat::Body::Suc { pred }) = (&dependencies.n.body) {
                if (tail.dependencies.n.body) == (**pred) {
                    Ok(Body::Cons {
                        val,
                        tail: Box::new(tail.body),
                    })
                } else {
                    Err(deps::ConstructorError::MismatchedDependencies)
                }
            } else {
                Err(deps::ConstructorError::MismatchedDependencies)
            }?;
            Ok(deps::Message { body, dependencies })
        }
    }
}

use vec::Vec;
