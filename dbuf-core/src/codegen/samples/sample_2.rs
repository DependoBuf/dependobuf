// this is rough sketch of some file that should be generated by codegen

// https://github.com/SphericalPotatoInVacuum/DependoBuf/blob/main/test/cpp_test_samples/dbuf_files/rt_dependent_messages.dbuf

// message Sum (a Int) {}

// message Foo (a Int) (b Int) {
//     sum Sum (-a + b);
// }

// message Bar (c Int) (s String) {
//     e Int;
//     d Int;
//     f Foo e d;
//     g Foo c (e + d);
// }

// message Kek (a Int) (b Int) (f Foo a b) {
//     bar Bar a "qwe";
// }

#[derive(Debug)]
pub enum ConstructorError {
    MismatchedDependencies,
}

#[derive(PartialEq, Eq)]
pub struct Message<Body, Dependencies> {
    pub body: Body,
    pub dependencies: Dependencies,
}

// actual generated part

// prelude
pub type Box<T> = std::boxed::Box<T>;

pub mod sum {
    mod deps {
        pub use super::super::{Box, ConstructorError, Message};
    }

    #[derive(PartialEq, Eq)]
    pub struct Body {}

    #[derive(PartialEq, Eq)]
    pub struct Dependencies {
        pub a: i32,
    }

    // alias for the generated type
    pub type Sum = deps::Message<Body, Dependencies>;

    // inherit implementation with all constructors
    impl Sum {
        pub fn new(dependencies: Dependencies) -> Result<Self, deps::ConstructorError> {
            let body = Body {};
            Ok(deps::Message { body, dependencies })
        }
    }
}

pub use sum::Sum;

// generated for Sum from
// -- dependobuf syntax
// message Sum (a Int) {}
// -- elaborated ast
// Its Type
// Type {
//     dependencies: vec![("a".to_owned(), Expression::Type {
//         name: "Int".to_owned(),
//         dependencies: Rec::new([]),
//     })],
//     constructor_names: ConstructorNames::OfMessage("Sum".to_owned()),
// }
// Corresponding part of constructors
// [(
//     "Sum".to_owned(),
//     Constructor {
//         implicits: vec![(
//             "a".to_owned(),
//             Expression::Type {
//                 name: "Int".to_owned(),
//                 dependencies: Rec::new([]),
//             },
//         )],
//         fields: Vec::new(),
//         result_type: Expression::Type {
//             name: "Sum".to_owned(),
//             dependencies: Rec::new([Expression::Variable {
//                 name: "a".to_owned(),
//             }]),
//         },
//     },
// )]

pub mod foo {
    use deps::sum;

    mod deps {
        pub use super::super::{sum, Sum};
        pub use super::super::{Box, ConstructorError, Message};
        pub use crate::try_block;
    }

    #[derive(PartialEq, Eq)]
    pub struct Body {
        pub sum: deps::Sum,
    }

    #[derive(PartialEq, Eq)]
    pub struct Dependencies {
        a: i32,
        b: i32,
    }

    // alias for the generated type
    pub type Foo = deps::Message<Body, Dependencies>;

    // inherit implementation with all constructors
    impl Foo {
        pub fn new(dependencies: Dependencies) -> Result<Self, deps::ConstructorError> {
            let body = Body {
                sum: deps::Sum::new(sum::Dependencies {
                    a: -dependencies.a + dependencies.b,
                })
                .expect("..."),
            };
            Ok(deps::Message { body, dependencies })
        }
    }
}

// generated for Sum from
// -- dependobuf syntax
// message Foo (a Int) (b Int) {
//     sum Sum (-a + b);
// }
// -- elaborated ast
// Its Type
// Type {
//     dependencies: vec![("a".to_owned(), Expression::Type {
//         name: "Int".to_owned(),
//         dependencies: Rec::new([]),
//     })],
//     constructor_names: ConstructorNames::OfMessage("Sum".to_owned()),
// }
// Corresponding part of constructors
// [(
//     "Foo".to_owned(),
//     Constructor {
//         implicits: vec![
//             (
//                 "a".to_owned(),
//                 Expression::Type {
//                     name: "Int".to_owned(),
//                     dependencies: Rec::new([]),
//                 },
//             ),
//             (
//                 "b".to_owned(),
//                 Expression::Type {
//                     name: "Int".to_owned(),
//                     dependencies: Rec::new([]),
//                 },
//             ),
//         ],
//         fields: vec![(
//             "sum".to_owned(),
//             Expression::Constructor {
//                 name: "Sum".to_owned(),
//                 implicits: Rec::new([Expression::OpCall(OpCall::Binary(
//                     super::operators::BinaryOp::Plus,
//                     Rec::new(Expression::OpCall(OpCall::Unary(
//                         super::operators::UnaryOp::Minus,
//                         Rec::new(Expression::Variable {
//                             name: "a".to_owned(),
//                         }),
//                     ))),
//                     Rec::new(Expression::Variable {
//                         name: "b".to_owned(),
//                     }),
//                 ))]),
//                 arguments: Rec::new([]),
//             },
//         )],
//         result_type: Expression::Type {
//             name: "Foo".to_owned(),
//             dependencies: Rec::new([
//                 Expression::Variable {
//                     name: "a".to_owned(),
//                 },
//                 Expression::Variable {
//                     name: "b".to_owned(),
//                 },
//             ]),
//         },
//     },
// )]
